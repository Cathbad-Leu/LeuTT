#NOP VSOF;
#NOP -------------------------------------------------------------------------;
#NOP File principale, carica e predisponi tutto;
#NOP -------------------------------------------------------------------------;

#VARIABLE {TELNET}
{
     {DO} {\xFD}
     {DONT} {\xFE}
     {IAC} {\xFF}
     {MSDP} {\x45}
     {SB} {\xFA}
     {SE} {\xF0}
     {WILL} {\xFB}
     {WONT} {\xFC}
     {GMCP} {\xC9}
}

#VARIABLE black <008>
#VARIABLE red <018>
#VARIABLE green <028>
#VARIABLE yellow <038>
#VARIABLE blue <048>blue
#VARIABLE magenta <058>
#VARIABLE cyan <068>
#VARIABLE white <078>
#VARIABLE light_black <108>
#VARIABLE light_red <118>
#VARIABLE light_green <128>
#VARIABLE light_yellow <138>
#VARIABLE light_blu <148>
#VARIABLE light_magenta <158>
#VARIABLE light_cyan <168>
#VARIABLE light_white <178>

#NOP -------------------------------------------------------------------------;
#NOP All'avvio chiede quale mud e personaggio usare;
#NOP -------------------------------------------------------------------------;

#EVENT {PROGRAM START}
{
    #SCREEN get rows gui[ROWS];
    #SCREEN get cols gui[COLS];
    #CONFIG {SCROLL_LOCK} {OFF};
    #CONFIG {VERBOSE} {OFF};
    #CONFIG {DEBUG TELNET} {OFF};
    #CONFIG {PACKET PATCH} {0.5};
    #CONFIG {MOUSE} {ON};
    #CONFIG {MOUSE TRACKING} {ON};
    #INFO {BUTTON} {OFF};
    #INFO {EVENT} {OFF};
    #CLASS worlddata read saves/muddata.dat;
    #if {&{worldlist} == 0}
    {
        #class worlddata open;
        #list worldlist clear;
        #class worlddata close;
    };
    #SPLIT;
    #SCREEN clear split;
    #ECHO {%h} {{ LUMEN ET UMBRA }};
    #ECHO { };
    #ECHO { CONNECT e il nome del mud se gia presente};
    #ECHO { ADDMUD nome host porta nome personaggio password};
    #ECHO { DELETEMUD nome mud per cancellare un mud};
    #ECHO { };
    #ECHO {%h};
    #READ {mslp.tin};
    #READ {gccp.tin};  
    connect
}

#ALIAS {addmud}
{
    #if {"%3" == ""}
    {
        #LINE ignore #SHOWME Syntax: addmud <nome> <host> <porta> [nome personaggio][password]
    };
    #else
    {
        #VARIABLE worldlist[%1][name] %1;
        #VARIABLE worldlist[%1][host] %2;
        #VARIABLE worldlist[%1][port] %3;
        #if {"%4" != ""}
        {
            #VARIABLE worldlist[%1][char] %4
        };
        #if {"%5" != ""}
        {
            #VARIABLE worldlist[%1][pass] %5
        };
        #if {&worldlist[%1][char]}
        {
            #LINE ignore #SHOWME Il mud %1 (%2 %3) ed il personaggio %4 (%5) sono stati aggiunti.
        };
        #else
        {
            #LINE ignore #SHOWME il mud %1 (%2 %3) è stato aggiunto.
        };
        #class worlddata write saves/muddata.dat
    };
    connect
}

#ALIAS {deletemud}
{
    #if {&worldlist[%1] != 0}
    {
        #UNVAR worldlist[%1];
        #CLASS worlddata write saves/muddata.dat;
        #LINE ignore #SHOWME Il mud %1 è stato cancellato.
    };
    #else
    {
        #ECHO {Il mud %s non è stato trovato nella lista.} {%1}
    };
    connect
}

#ALIAS {connect}
{
    #if {"%1" == ""}
    {
        #ECHO {%h} {{ MUD LIST }};
        #ECHO { };
        #foreach {*worldlist[]} {world}
        {
            #ECHO { %-10s %s %s %s %s} {$worldlist[$world][name]} {$worldlist[$world][host]} {$worldlist[$world][port]} {$worldlist[$world][char]} {\e]68;2;EXEC;connect $world\a\e[4mconnect\e[24m};
        };
        #ECHO { };
        #ECHO {%h};
    };
    #elseif {&worldlist[%1] != 0}
    {
        #VARIABLE mud {%1};
        #SESSION $worldlist[%1][name] $worldlist[%1][host] $worldlist[%1][port]
    };
    #else
    {
        #ECHO {Non è stato possibile trovare %1.}
    };
}

#NOP -------------------------------------------------------------------------;
#NOP Eventi di sessione;
#NOP -------------------------------------------------------------------------;

#EVENT {SESSION ACTIVATED}
{
    #NOP;
}

#EVENT {SESSION CONNECTED}
{
    #VARIABLE mud @gts{$mud};
    #if {&worldlist[$mud]}
    {
        #if {&worldlist[$mud][char]}
        {
            #SEND {$worldlist[$mud][char]};
            #if {&worldlist[$mud][pass]}
            {
                #read {gui.tin};
                gui_init
            };
        };
    };
}

#EVENT {SESSION DISCONNECTED}
{
    #map write saves/map.dat
}

#EVENT {SESSION DESTROYED}
{
    #gts #delay 0 #end
}

#NOP -------------------------------------------------------------------------;
#NOP EVENTI VARI;
#NOP -------------------------------------------------------------------------;

#EVENT {IAC WILL MSDP}
{
    #SEND {$TELNET[IAC]$TELNET[DO]$TELNET[MSDP]\};
    #delay 1 msdp_report
}

#EVENT {IAC SB MSDP}
{
    #VARIABLE {MSDP_%0} {%1}
}

#EVENT {IAC SB MSDP SCREEN_WIDTH}
{
    #variable gui[MSDP_SCREEN_WIDTH] {%1}
}

#EVENT {IAC SB MSDP SCREEN_HEIGHT}
{
    #variable gui[MSDP_SCREEN_HEIGHT] {%1}
}

#EVENT {IAC SB MSDP IAC SE}
{
    #nop;
}

#EVENT {IAC SB MSDP AC}
{
    #if {&inmud != 0} 
    {
        gui_refresh
    };
}

#EVENT {IAC SB NAWS}
{  
    #if {&inmud != 0} 
    {
        gui_refresh
    };
}

#EVENT {SCREEN RESIZE}
{ 
    #screen refresh;
    #buffer end
}

#EVENT {SCREEN ROTATE LANDSCAPE}
{
    #if {&inmud != 0} 
    {
       gui_rotate_landscape
    };
}

#EVENT {SCREEN ROTATE PORTRAIT}
{ 
    #if {&inmud != 0} 
    {
       gui_rotate_portrait
    };
}

#EVENT {RECEIVED LINE}
{
    #if {&inmud != 0} 
    {
       gui_line_update
    };
}

#EVENT {RECEIVED ERROR}
{
	#echo <118>%h { TOKENIZER };
	#info tokenizer -1;
	#echo <118>%h;
}

#EVENT {IAC WILL GMCP}
{
    #SEND {$TELNET[IAC]$TELNET[DO]$TELNET[GMCP]\};
}

#EVENT {IAC SB GMCP char.vitals IAC SE}
{
    #VARIABLE gmcp[char][vitals] {%0};
	
    #VARIABLE pg[chp] {$gmcp[char][vitals][hp]};
    #VARIABLE pg[mhp] {$gmcp[char][vitals][maxhp]};
	
    #VARIABLE pg[cmn] {$gmcp[char][vitals][mana]};
    #VARIABLE pg[mmn] {$gmcp[char][vitals][maxmana]};
	
    #VARIABLE pg[cmv] {$gmcp[char][vitals][mov]};
    #VARIABLE pg[mmv] {$gmcp[char][vitals][maxmov]};
	
    #VARIABLE pg[cen] {$gmcp[char][vitals][pow]};
    #VARIABLE pg[men] {$gmcp[char][vitals][maxpow]};
	
    #VARIABLE pg[pos] {$gmcp[char][vitals][roomPos]};
	
    #VARIABLE tm[crd] {$gmcp[char][vitals][roundTicker]};
    #VARIABLE tm[mrd] {$gmcp[char][vitals][roundMax]};
    #VARIABLE tm[tik] {$gmcp[char][vitals][secsToTick]}
}

#NOP -------------------------------------------------------------------------;
#NOP Se rientri da ld richiedi al mud le variabili msdp;
#NOP -------------------------------------------------------------------------;

#ACTION {Ritrovi il senso della realta' ma sei un po' stordito.}
{
    msdp_ask_hpbar
}

#NOP -------------------------------------------------------------------------;
#NOP Riga di comando stile zmud, mantine il comando digitato;
#NOP e lo evidenzia in blu. se dato;
#NOP -------------------------------------------------------------------------;

#CONFIG REPEAT_ENTER ON

#VARIABLE last_input {}

#EVENT {HISTORY UPDATE}
{
    #DELAY 0 #LINE ignore #SHOWME {<aaf><FFF><788>%0<088>} {-1};
    #VARIABLE last_input {%0}
}

#EVENT {PROCESSED KEYPRESS}
{
	#if {{%1} != {10} && {$last_input} !== {}}
	{
		#VARIABLE last_input {};
		#LINE ignore #SHOWME {} {-1};
		#cursor end;
		#history insert {}
	};
}

#NOP -------------------------------------------------------------------------;
#NOP Execute speedwalks with .;
#NOP -------------------------------------------------------------------------;

#alias {.%0}
{
	#var cnt {};

	#parse {%0} {char}
	{
		#if {"$char" >= "0" && "$char" <= "9"}
		{
			#var cnt $cnt$char
		};
		#elseif {"$cnt" == ""}
		{
			#send $char
		};
		#else
		{
			#$cnt #send $char;
			#var cnt {}
		};
	}
}


#NOP -------------------------------------------------------------------------;
#NOP Use mouse click to change the input cursor's position.;
#NOP -------------------------------------------------------------------------;

#EVENT {SHORT-CLICKED MOUSE BUTTON ONE -1}
{
	#cursor position %1
}

#NOP -------------------------------------------------------------------------;
#NOP Contatore di mob uccisi  ed esperienza;
#NOP -------------------------------------------------------------------------;

#list gains clear

#ACTION {%1 e` morto! R.I.P.}
{
    #variable mob %1;
    #if {&targets[%1]} {target %1};
}

#ACTION {La tua esperienza e` aumentata di %1 punti.}
{
    #math {gains[$mob][mobexp]} {$gains[$mob][mobexp] + %1};
    #math {gains[$mob][mobcnt]} {$gains[$mob][mobcnt] + 1}
}

#ALIAS {rip}
{
    #showme {      Average Xp      Totale Xp     #   Death List, R.I.P.};
    #showme {----------------------------------------------------------};
    #unvariable {gains[final]};
    #foreach {*gains[]} {mob}
    {
        #echo {  %+14g %+14g %+5g   %s}{$gains[$mob][mobexp] / $gains[$mob][mobcnt]}{$gains[$mob][mobexp]}{$gains[$mob][mobcnt]}{$mob};
        #math gains[final][mobexp] $gains[final][mobexp] + $gains[$mob][exp];
        #math gains[final][mobcnt] $gains[final][mobcnt] + $gains[$mob][mobcnt]
    };
    #showme {----------------------------------------------------------};
    #math mobtmp {$gains[final][mobexp] / $gains[final][mobcnt]};
    #echo {  %+14g %+14g %+5g}{$mobtmp}{$gains[final][mobexp]}{$gains[final][mobcnt]}
}

#NOP -------------------------------------------------------------------------;
#NOP LOG on or off;
#NOP -------------------------------------------------------------------------;
#ALIAS {log}
{
     #if {"%0" == "on"}
     {
          #if {"$logging" != "on"}
          {
               #FORMAT {logfile} {logs/%t.html} {%Y-%m-%d};
               #log append $logfile;
               #VARIABLE logging on;
          };
          #else
          {
               #LINE ignore #SHOWME Stai già facendo un log.;
          }
     };
     #elseif {"%0" == "off"}
     {
          #if {"$logging" == "on"}
          {
               #log off;
               #VARIABLE logging off;
          };
          #else
          {
               #LINE ignore #SHOWME You are not logging.;
          };
     };
     #else
     {
          #LINE ignore #SHOWME Turn logging on or off?;
     };
}
